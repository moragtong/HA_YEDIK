#pragma once
#ifndef SOCKET_H 
#define SOCKET_H 

//#ifdef _WIN32 // _WIN32 is defined by many compilers available for the Windows operating system, but not by others.
#define WIN_SOCK_DECLARE		WSADATA wsaData;

//********* WIN_SOCK_INIT & WIN_SOCK_SHUTDOWN should be called for each thread
#define WIN_SOCK_INIT			WSAStartup(MAKEWORD(2,2), &wsaData); 
#define WIN_SOCK_SHUTDOWN		WSACleanup();
//*****************************************************************************

#define GET_LAST_SOCKET_ERROR	WSAGetLastError();
#define socklen_t		int 

/*#else

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <netdb.h>

#define WIN_SOCK_DECLARE
#define WIN_SOCK_INIT
#define WIN_SOCK_SHUTDOWN

//	#define GET_LAST_SOCKET_ERROR	errno;
#define SOCKET 			int
#define INVALID_SOCKET		(-1)

#endif*/

namespace Socket {
	namespace detail {
		class Socket_Base {
			/*Socket_Base(const Socket_Base &) = delete;
			void operator=(const Socket_Base &) = delete;*/
		protected:
			SOCKET sock;
			sockaddr_in sock_info;
			Socket_Base() {
				sock = INVALID_SOCKET;
				::memset(&sock_info, 0, sizeof(sock_info));
			}
			void SetSOCK(SOCKET Sock) {
				if (Sock > 0) {
					sock = Sock;
				}
			}
			int Bind(unsigned short nPort) {
				sock_info.sin_family = AF_INET;
				sock_info.sin_port = htons(nPort);
				sock_info.sin_addr.s_addr = htonl(INADDR_ANY);
				return ::bind(sock, (sockaddr*)&sock_info, sizeof(sock_info));
			}
		public:
			void CloseSocket() {
				if (sock != INVALID_SOCKET) {
#ifdef _WIN32
					::closesocket(sock);
#else
					::close(sock);
#endif	
				}
				sock = INVALID_SOCKET;
				::memset(&sock_info, 0, sizeof(sock_info));
			}
			int SetNonBlockingMode(bool bBlockingMode) {
#ifdef _WIN32
				unsigned long nFlag;
				if (bBlockingMode) {
					nFlag = 1; //for non-blocking mode...
				} else {
					nFlag = 0; //for blocking mode...
				}
				return ::ioctlsocket(sock, FIONBIO, &nFlag);
#else
				int nFlag;
#if defined(O_NONBLOCK)
				if (-1 == (nFlag = ::fcntl(sock, F_GETFL, 0))) {
					nFlag = 0;
				}
				return ::fcntl(sock, F_SETFL, nFlag | O_NONBLOCK);
#else
				nFlag = 1;
				return ::ioctl(sock, FIONBIO, &nFlag);
#endif
#endif
			}
			bool IsValidSocket() {
				return INVALID_SOCKET != sock;
			}
			~Socket_Base() {
				CloseSocket();
			}
		};
		class TCP : public Socket_Base {
		protected:
			TCP() {}
		public:
			using Socket_Base::SetSOCK;
			bool Create() {
				sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
				return INVALID_SOCKET != sock;
			}
			int Send(const void *pBuff, size_t nBuffSize, int nFlags = 0) const {
				return ::send(sock, (const char*)pBuff, nBuffSize, nFlags);
			}
			int Recv(void *pBuff, size_t nBuffSize, int nFlags = 0) {
				return ::recv(sock, (char*)pBuff, nBuffSize, nFlags);
			}
		};
	}
	struct TCPClient : detail::TCP {
		int Connect(const char *pszAddr, unsigned short nPort) {
			auto hp = ::gethostbyname(pszAddr);
			::memcpy(&sock_info.sin_addr, hp->h_addr, hp->h_length);
			sock_info.sin_family = AF_INET;
			sock_info.sin_port = ::htons(nPort);
			return ::connect(sock, (sockaddr*)&sock_info, sizeof(sock_info));
		}
	};
	struct TCPServer : detail::TCP {
		using Socket_Base::Bind;
		int Listen(int nQueueWait = 5) {
			return ::listen(sock, nQueueWait);
		}
		TCPClient Accept() {
			TCPClient pSockClient;
			SOCKET sock_temp = ::accept(sock, nullptr, nullptr);
			if (sock_temp != INVALID_SOCKET)
				pSockClient.SetSOCK(sock_temp);
		}
	};
	struct UDP : detail::Socket_Base {
		using Socket_Base::Bind;
		bool Create() {
			sock = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
			return INVALID_SOCKET != sock;
		}
		int RecvFrom(void *pBuff, size_t nBuffSize, sockaddr_in *client_addr, int nFlag = 0) {
			socklen_t nLen = sizeof(client_addr);
			return ::recvfrom(sock, (char*)pBuff, nBuffSize, nFlag, (struct sockaddr *)client_addr, &nLen);
		}
		int SendTo(void *pBuff, size_t nBuffSize, sockaddr_in &client_addr, int nFlag = 0) {
			return ::sendto(sock, (const char*)pBuff, nBuffSize, nFlag, (struct sockaddr *)&client_addr, sizeof(client_addr));
		}
	};
} //Namespace Socket

#endif //for #define SOCKET_H 
